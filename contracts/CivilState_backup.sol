// SPDX-License-Identifier: MIT
pragma solidity >=0.4.21 <0.8.0;

/* 
* Libraries needed in the contract 'Civil State' contract
*/
/** @title LibConcatenateStrings. */
/// @dev Library with a function for concatenating strings
import {LibConcatenateStrings} from './LibConcatenateStrings.sol';
/** @title LibTransformUintString. */
/// @dev Library with a function to transform an 'uint' in a 'string
import {LibTransformUintString} from './LibTransformUintString.sol';
/** @title SafeMath. */
/** 
 * @dev Library with functions to realize arithmetic operations with overflow checks
 *
 * Contract collection retrieved from : https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol
 *
*/
import {SafeMath} from './SafeMath.sol';

/** @title CivilState. */
contract CivilState_backup {
    /// @dev Include libraries codes and initialize its use in the contract
    using LibConcatenateStrings for string;
    using LibTransformUintString for *;
    using SafeMath for uint; 

    /**
     * @dev State variable to allow contract functionnlity to be stopped
     * For implementing circuit breaker pattern
     */ 
    bool public stopped = false;
    
    /// @dev Owner address
    address payable public owner;

    /** 
    * @dev Contains the birth elements 
    * Elements : name, last name, birth date, birth city and verification status
    */
    struct Birth {
        string name;
        string lastName;
        string birthDate;
        string birthCity;
        bool isVerified;
    }

    /** 
    * @dev Contains the identity elements 
    * Elements : information from the birth, marital status, marriage date and user login
    */    
    struct Identity {
        Birth birthinfo;
        string maritalStatus;
        string marriageDate;
        string userLogin;
    }

    /** 
    * @dev Contains users (citizens) identifiers 
    * Elements : 
    *   - Identification number
    *   - Hash of the user's password
    *   - Hash of the last certification generated by the user
    */    
    struct Identifier {
        uint userIdentityCount;
        bytes32 userPassword;
        bytes32 newCertification;
    }

    /** 
    * @dev Contains hospital, prefecture and city hall members authentification information
    * Elements : member login, member name
    */    
    struct Authentification {
        string login;
        string name;
    }
    
    
    /// @dev Maps hospital members addresses to their authentification information
    mapping (address => Authentification) hospitalMembers;

    /// @dev Maps prefecture members addresses to their authentification information
    mapping (address => Authentification) prefectureMembers;

    /// @dev Maps city hall members addresses to their authentification information
    mapping (address => Authentification) cityHallMembers;

    /// @dev Maps births identifications to the birth information
    mapping (uint => Birth) births;
    uint birthsCount = 0;

    /// @dev Maps identities identifications to the identity (citizen) information 
    mapping (uint => Identity) identities;
    uint identitiesCount = 0;

    /// @dev Maps user login (string) to the user identifier
    mapping(string => Identifier) citizenIdentifiers;

    /// @dev Maps user certification hash (bytes32) to the user identifier
    mapping(bytes32 => Identifier) idCertifications;

    /**
     * Events
     */ 
    /// @dev Event signaling that a new hospital member was added
    event LogEventAddHospitalMember(string memberName);
    /// @dev Event signaling that a new prefecture member was added
    event LogEventAddPrefectureMember(string memberName);
    /// @dev Event signaling that a new cityHall member was added
    event LogEventAddCityHallMember(string memberName);
    /// @dev Event signaling that a new birth member was declared
    event LogEventBirthAdded (string name, string lastName, uint birthId);
    
    /// @dev Event signaling that a new identity was verified
    event LogEventVerifyIdentity(uint birthId, uint identityId);
    event LogEventChangeName(uint birthId, string newName);
    event LogEventChangeLastName(uint birthId, string newLastName);
    event LogEventChangeBirthCity(uint birthId, string newBirthCity);
    event LogEventChangeBirthDate(uint birthId, string newBirthDate);

    /// @dev Event signaling that new marriage member was declared
    event LogEventDeclareMarriage(string marriageDate, uint identityId);
    /// @dev Event signaling that a certification was generated
    event LogEventCertificationGenerated(string login, bytes32 identity_hash);
    /// @dev Event verifying a certification
    event LogEventVerifyCertification (string name, string lastName, string birthDate, string birthCity, string maritalStatus);

    /**
     * Modifiers
     */ 

    /**
     * @dev Permit certain functions only when 'stopped' is false
     * Circuit breaker pattern
     */
    modifier stopInEmergency { 
        require(!stopped); _; 
    }
    /**
     * @dev Permit withdraw function only when 'stopped' is true
     * Circuit breaker pattern
     */    
    modifier onlyInEmergency { 
        require(stopped); _; 
    }    

    
    
    /// @dev Throws an error if the msg.sender is not the owner.
    modifier isAdmin () {
        require(owner == msg.sender);
        _;
    }

    /// @dev Throws an error if the msg.sender is not a hospital member.
    modifier isHospital () {
        require (bytes(hospitalMembers[msg.sender].name).length > 0);
        _;
    }

    /// @dev Throws an error if the msg.sender is not a prefecture member.
    modifier isPrefecture () {
        require (bytes(prefectureMembers[msg.sender].name).length > 0);
        _;
    }

    /// @dev Throws an error if the msg.sender is not a city hall member.
    modifier isCityHall () {
        require (bytes(cityHallMembers[msg.sender].name).length > 0);
        _;
    }

    /// @dev Contract constructor sets the owner
    constructor () public {
        owner = msg.sender;
    }    
  

    /**
     * @dev Changes stopped state variable to 'true'
     * Only the admin (owner) can call it
     * Circuit breaker pattern
     */
    function stopCivilStateContract() public isAdmin {
        stopped = true;
    }

    /**
     * @dev Withdraws contract balance to the owner's account
     * Only the admin (owner) can call it
     * Only possible when 'stopped' is true
     * Circuit breaker pattern
     */
    function withdraw() onlyInEmergency public {
        owner.transfer(address(this).balance);
    }

    /**
     * @dev Destroys contract and removes it from the blockchain
     * Only the admin (owner) can call it
     * Mortal pattern
     */
    function kill() public isAdmin {

        selfdestruct(address(uint160(owner))); // cast owner to address payable
    }

    /**
     * Helper functions
     */
    /// @dev Gets the births count.
    /// @return birthsCount Births count.
    function getBirthsCount() public view returns(uint) {
        return birthsCount; 
    }

    /// @dev Gets the identitues count.
    /// @return identitiesCount Identities count.
    function getIdentitiesCount() public view returns(uint){
        return identitiesCount;
    }

    /// @dev Gets owner address.
    /// @return Owner's address.
    function getOwner() public view returns(address){
        return owner;
    }

    /// @dev Verifies if the msg.sender is a hospital member.
    /// @return The hospital member address (if it is a member, otherwise return '0x..0').
    function isHospitalMember() public view returns(address){
        address memberAddress;
        if (bytes(hospitalMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

    /// @dev Verifies if the msg.sender is a prefecture member.
    /// @return The prefecture member address (if it is a member, otherwise return '0x..0').
    function isPrefectureMember() public view returns(address){
        address memberAddress;
        if (bytes(prefectureMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

    /// @dev Verifies if the msg.sender is a city hall member.
    /// @return The city hall member address (if it is a member, otherwise return '0x..0').
    function isCityHallMember() public view returns(address){
        address memberAddress;
        if (bytes(cityHallMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }
   
    /**
     * Admin functions
     */

    /// @dev Adds a hospital member.
    /// @param _newMember Address of the new member.
    /// @param _memberName Name of the new member.
    function addHospitalMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName);       
        hospitalMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddHospitalMember(_memberName);
    }

    /// @dev Adds a prefecture member.
    /// @param _newMember Address of the new member.
    /// @param _memberName Name of the new member.
    function addPrefectureMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName); 
        prefectureMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddPrefectureMember(_memberName);
    }

    /// @dev Adds a city hall member.
    /// @param _newMember Address of the new member.
    /// @param _memberName Name of the new member.
    function addCityHallMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName); 
        cityHallMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddCityHallMember(_memberName);
    }

    /**
     * Hospital members functions
     */

    /// @dev Adds a new birth.
    /// @param _name Birth name.
    /// @param _lastName Birth last name.
    /// @param _birthDate Birth date.
    /// @param _birthCity Birth city.
    /// @return birthId The birth identification.       
    function addBirth (string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity) public isHospital stopInEmergency returns(uint) {
        uint birthId = birthsCount;
        birthsCount = birthsCount.add(1);
        births[birthId] = Birth({
            name : _name,
            lastName : _lastName,
            birthDate : _birthDate,
            birthCity : _birthCity,
            isVerified : false
        });
        emit LogEventBirthAdded(_name, _lastName, birthId);
        return birthId;
    }

    /// @dev Gets the identification of the last birth added  
    /// @return _birthId Birth identification of the last birth added.
    /// @return _name Birth name of the last birth added.
    /// @return _lastName Birth last name of the last birth added.    
    function getBirthId () public view returns (uint _birthId, string memory _name, string memory _lastName){
        if (birthsCount == 0) {
          _birthId = birthsCount;  
        } else {
          _birthId = birthsCount.sub(1);  
        }
        _name = births[_birthId].name;
        _lastName = births[_birthId].lastName;
 
    }

    /**
     * Prefecture members functions
     */

    function changeName (uint birthId, string memory newName) public isPrefecture stopInEmergency {
        require(births[birthId].isVerified == false);
        births[birthId].name = newName;
        emit LogEventChangeName(birthId, newName);        
    }
    
    function changeLastName (uint birthId, string memory newLastName) public isPrefecture stopInEmergency {
        require(births[birthId].isVerified == false);
        births[birthId].lastName = newLastName;
        emit LogEventChangeLastName(birthId, newLastName);        
    }             

    function changeBirthCity (uint birthId, string memory newBirthCity) public isPrefecture stopInEmergency {
        require(births[birthId].isVerified == false);
        births[birthId].birthCity = newBirthCity;
        emit LogEventChangeBirthCity(birthId, newBirthCity);        
    }

    function changeBirthDate (uint birthId, string memory newBirthDate) public isPrefecture stopInEmergency {
        require(births[birthId].isVerified == false);
        births[birthId].birthDate = newBirthDate;
        emit LogEventChangeBirthDate(birthId, newBirthDate);        
    }

    /// @dev Verifies an identity.
    /// @param birthId Birth identitication to verify.
    /// @return identityId The identity identification.
    function verifyIdentity (uint birthId) public isPrefecture stopInEmergency returns (uint identityId) {
        require(births[birthId].isVerified == false);
        births[birthId].isVerified = true;
        
        string memory login = "login_";
        string memory _login = login.concatenate(births[birthId].lastName); 
        login = _login.concatenate(births[birthId].birthDate);        
        
        string memory pwd = "pwd_";
        string memory password = pwd.concatenate(births[birthId].birthDate);
        bytes32 passwordHash = keccak256(bytes(password));

        bytes32 lambdaCertification = keccak256(bytes("new"));

        identityId = identitiesCount;
        identitiesCount = identitiesCount.add(1);
        identities[identityId] = Identity({
            birthinfo : births[birthId],
            maritalStatus : "single",
            marriageDate: "",
            userLogin: login
        });

        citizenIdentifiers[login] = Identifier({
            userIdentityCount : identityId,
            userPassword : passwordHash,
            newCertification : lambdaCertification
        });

        emit LogEventVerifyIdentity(birthId, identityId);
    }

    /// @dev Gets the identification of the last identity verified  
    /// @return _identity Identity identification of the last identity verified.
    /// @return _name Identity name of the last identity verified.
    /// @return _lastName Identity last name of the last identity verified.
    function getIdentityId() public view returns (uint _identity, string memory _name, string memory _lastName){
        if (identitiesCount == 0) {
          _identity = identitiesCount;  
        } else {
          _identity = identitiesCount.sub(1);  
        }
        _name = identities[_identity].birthinfo.name;
        _lastName = identities[_identity].birthinfo.lastName; 
    }

    /**
     * City hall members functions
     */  

    /// @dev Declares a marriage.
    /// @param identityId Idenity identitication to declare marriage.
    /// @param _marriageDate Marriage date.
    function declareMarriage (uint identityId, string memory _marriageDate) public isCityHall stopInEmergency {
        require(identities[identityId].birthinfo.isVerified == true);
        
        identities[identityId].maritalStatus = "married";
        identities[identityId].marriageDate = _marriageDate;

        emit LogEventDeclareMarriage(_marriageDate, identityId);
    }

    /**
     * Citizens (users) and responsible entities functions
     */

    /// @dev Changes the password.
    /// @param _login User login.
    /// @param _oldPwd Old password.
    /// @param _newPwd New password.    
    function modifyMyPassword (string memory _login, string memory _oldPwd, string memory _newPwd) public{
        //Verify that the user used the good password
        require (citizenIdentifiers[_login].userPassword == keccak256(bytes(_oldPwd)));
        bytes32 newPwd = keccak256(bytes(_newPwd));
        citizenIdentifiers[_login].userPassword = newPwd;
    }

    /// @dev Generates identity certification.
    /// @param login User login.
    /// @param pwd User password.
    /// @return identity_hash The certification hash.
    function generateIdCertification (string memory login, string memory pwd) public returns (bytes32){
        //Verify that the user used the good password
        require (citizenIdentifiers[login].userPassword == keccak256(bytes(pwd)));
        // Get the user identity count
        uint userIdCount = citizenIdentifiers[login].userIdentityCount;
        string memory userIdCountString = userIdCount.uintToString();
        string memory contIdentifiers = userIdCountString.concatenate(pwd);
        bytes32 identity_hash = keccak256(bytes(contIdentifiers));
        citizenIdentifiers[login].newCertification = identity_hash;
        // add certification to mapping
        idCertifications[identity_hash] = citizenIdentifiers[login];
        emit LogEventCertificationGenerated(login, identity_hash);
        return identity_hash;
    }
    
    /// @dev Gets the hash of the last certification generated by the user
    /// @param _login User login.
    /// @return identity_hash The certification hash.
    function getCertification(string memory _login) public view returns (bytes32) {
        return citizenIdentifiers[_login].newCertification;
    }
    
    /// @dev Verifies a certification
    /// @param id_hash The certification hash.
    /// @return _name The citizen name.
    /// @return _lastName The citizen last name.
    /// @return _birthDate The citizen birth date.
    /// @return _birthCity The citizen birth city.
    function verifyCertification (bytes32 id_hash) public returns (string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, string memory _maritalStatus) {
        // get userIdCount
        uint userIdCount = idCertifications[id_hash].userIdentityCount;
        emit LogEventVerifyCertification (identities[userIdCount].birthinfo.name, identities[userIdCount].birthinfo.lastName, identities[userIdCount].birthinfo.birthDate, identities[userIdCount].birthinfo.birthCity, identities[userIdCount].maritalStatus);
        return(identities[userIdCount].birthinfo.name, identities[userIdCount].birthinfo.lastName, identities[userIdCount].birthinfo.birthDate, identities[userIdCount].birthinfo.birthCity, identities[userIdCount].maritalStatus);

    }
    
    /**
     * Read functions
     */

    /// @dev Gets a birth information
    /// @param birthId The birth identification.
    /// @return _name The birth name.
    /// @return _lastName The birth last name.
    /// @return _birthDate The birth date.
    /// @return _birthCity The birth city.
     /// @return _isVerified The birth verification status.   
    function readBirth(uint birthId) public view returns(string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, bool _isVerified){
        return (births[birthId].name, births[birthId].lastName, births[birthId].birthDate, births[birthId].birthCity, births[birthId].isVerified);
    }        

    /// @dev Gets an identity information
    /// @param identityId The identity identification.
    /// @return _name The citizen name.
    /// @return _lastName The citizen last name.
    /// @return _birthDate The citizen birth date.
    /// @return _birthCity The citizen birth city.
    /// @return _maritalStatus The citizen marital status.    
    function readIdentity(uint identityId) public view returns(string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, string memory _maritalStatus){
        require(identities[identityId].birthinfo.isVerified == true);
        return (identities[identityId].birthinfo.name, identities[identityId].birthinfo.lastName, identities[identityId].birthinfo.birthDate, identities[identityId].birthinfo.birthCity, identities[identityId].maritalStatus);
    }
 
}